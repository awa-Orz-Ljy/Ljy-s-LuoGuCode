#include<bits/stdc++.h>
using namespace std;
string s;
int a[40],maxx,minn = 114514;
//判断质数的函数
bool isprime(int n){
	if(n == 0||n == 1)return false;
	for(int i = 2;i*i <= n;i ++){
		if(n % i == 0)return false;
	}
	return true;
}

int main(){
	cin >> s;
	for(int i = 0;i < s.size();i ++){
		//由字符串数组转换到字母的次数相加：(int)(s[i] - 'a' + 1)，出现的字母的下标
		a[(int)(s[i] - 'a' + 1)] ++;
		maxx = max(maxx,a[(int)(s[i] - 'a' + 1)]);
	}	
	for(int i = 1;i <= 26;i ++){
		if(a[i]!= 0) minn = min(minn,a[i]);
	}
	//后面就简单了
	if(isprime(maxx - minn)){
		cout<<"Lucky"<<" "<<"Word"<<endl<<maxx - minn;
	}else{
		cout<<"No"<<" "<<"Answer"<<endl<<"0";
	}
	return 0;
}
/*
首先，函数一开始检查n是否为0或者1，如果是的话直接返回false。
因为0和1都不是质数对吧。那这部分我理解，质数的定义是大于1的自然数，
只能被1和自身整除。所以这两个情况直接排除是对的。

接下来是循环部分，循环变量i从2开始，直到i的平方小于等于n。
循环内部判断n是否能被i整除，如果能，返回false，说明不是质数。
如果循环结束后都没找到因数，就返回true，说明是质数。

那这里的关键是循环的条件为什么是i*i <=n呢？
比如，假设我们要判断n是否为质数，比如n=17，那么循环的i会从2到4，
因为当i=4的时候，4*4=16<=17，i=5的时候，5*5=25>17，所以循环结束。
那这个时候i的范围是2到sqrt(n)取整数部分，比如sqrt(17)约等于4.123，
所以i最大到4。这样做的道理是什么呢？

---------------------------------------------------------------------------------------
哦，对了，因为如果n有一个大于sqrt(n)的因数，
那么对应的另一个因数必定小于sqrt(n)。
比如n=15，sqrt(15)约3.87，这时候i循环到3。
15的因数是3和5，3小于sqrt(15)，5大于。
所以如果存在一个因数大于sqrt(n)，那么必然有一个因数小于等于sqrt(n)。
所以在循环的时候，只需要检查到sqrt(n)即可，如果到这个时候还没找到因数，
那么后面也不会有因数了。这样就能减少循环次数，提高效率。
----------------------------------------------------------------------------------------

那举个例子，假设n是25，那么sqrt(n)是5，i会循环到5。
这时候i=5的时候，25%5==0，返回false，说明不是质数。
而如果是n=23，sqrt(n)≈4.795，所以i循环到4。检查2、3、4，都不能整除，
所以返回true。这正确，因为23是质数。

那如果n是2的话呢？比如i从2开始，此时i*i=4，
当n=2时，i*i<=n的条件是4<=2吗？不成立，所以循环不会执行，
直接返回true。那正确，因为2是质数。

同样，n=3的时候，i=2，i*i=4>3，循环不执行，返回true。正确。

那如果是n=4的话，i从2开始，i*i=4<=4，
进入循环，4%2==0，返回false。正确，因为4不是质数。
*/